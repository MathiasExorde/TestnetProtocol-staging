// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


contract DeletableMapping {
    // Input is keccak256(uint32 mappingVersion, string carVIN)
    mapping (bytes32 => string) data_files;
    uint32 currentMappingVersion;

    function getData(string _ipfsHash) external view returns(string) {
        bytes32 key = keccak256(currentMappingVersion, _carVIN);
        return Datas[key];
    }

    function setData(string _URLHash, string _DataJSON) external {
        bytes32 key = keccak256(currentMappingVersion, _carVIN);
        Datas[key] = _DataJSON;
    }

    function deleteAllDatas() external {
        currentMappingVersion++;
    }

    function recoverGas(uint32 _version, string _URLHash) external {
        require(_version < currentMappingVersion);
        bytes32 key = keccak256(_version, _carVIN);
        delete(Datas[key]);
    }
}

contract WorkSystem is Ownable {

    // ============
    // EVENTS:
    // ============

    event _Spot(uint indexed spotID, string IPFS_hash, address indexed author);
    // ============
    // DATA STRUCTURES:
    // ============

    using SafeMath for uint;
    
    enum HashStatus{
        TBD,
        VALID,
        DELETED
    }

    struct Spot {
        bytes32 ipfs_hash;                      /// expiration date of commit period for poll
        address author;                         /// author of the proposal
        string url_domain;                         /// author of the proposal
        string tag;                         /// author of the proposal
        HashStatus status;                      /// state of the poll
        uint date;                     /// Date of submission
    }
    
    
    modifier hasStake(address _avatar) {
        require(_avatar == address(avatar));
        _;
    }

    // ============
    // STATE VARIABLES:
    // ============

    
    uint256 public roundId = 0;
    uint256 internal previousSeed = 0;


    uint256 spotCounter = 0;
    uint public MIN_STAKE;
    mapping(uint => Spot) public Spottings; // maps SpotID to Poll struct

    
    mapping(address => uint256[]) public userSpots; // maps user's adresses to pollIDs they started
    mapping(address => uint) public UserStakeBalance; // maps user's address to voteToken balance
    
    IERC20 public token;

    /**
    @dev Initializer. Can only be called once.
    */
    constructor() {
        MIN_STAKE = 100 * (10 ** 18);
    }
    

    // =================
    // SPOTTING INTERFACE:
    // =================


    /**
    @dev Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event
    */
    function SpotInfo(bytes32 file_hash, string memory domain, string[] memory tag, uint size) public returns (uint256 spot_id) {
        
        require(file_hash != 0);       
        require(size > 0);

        spotCounter = spotCounter + 1;
        
        userSpots[msg.sender].push(spotCounter);

        Spottings[spotCounter] = Spot({
            ipfs_hash: file_hash,
            author: msg.sender,
            url_domain: domain,
            tag: tag,
            status: HashStatus.TBD,
            date: block.timestamp
        });

        emit _Spot(spotCounter, IPFS_hash, msg.sender);
        
        return spotCounter;
    }
    

}
