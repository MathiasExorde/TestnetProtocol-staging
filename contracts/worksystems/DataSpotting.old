// SPDX-License-Identifier: GPL-3.0
// File: attrstore/AttributeStore.sol

pragma solidity 0.8.0;

library AttributeStore {
    struct Data {
        mapping(bytes32 => uint) store;
    }

    function getAttribute(Data storage self, bytes32  _UUID, string memory _attrName)
    public view returns (uint) {
        
        bytes32 key = keccak256(abi.encodePacked(_UUID, _attrName));
        return self.store[key];
    }

    function setAttribute(Data storage self, bytes32 _UUID, string memory _attrName, uint _attrVal)
    public {
        bytes32 key = keccak256(abi.encodePacked(_UUID, _attrName));
        self.store[key] = _attrVal;
    }
}

// File: dll/DLL.sol

library DLL {

  uint constant NULL_NODE_ID = 0;

  struct Node {
    uint next;
    uint prev;
  }

  struct Data {
    mapping(uint => Node) dll;
  }

  function isEmpty(Data storage self) public view returns (bool) {
    return getStart(self) == NULL_NODE_ID;
  }

  function contains(Data storage self, uint _curr) public view returns (bool) {
    if (isEmpty(self) || _curr == NULL_NODE_ID) {
      return false;
    } 

    bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);
    bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);
    return isSingleNode || !isNullNode;
  }

  function getNext(Data storage self, uint _curr) public view returns (uint) {
    return self.dll[_curr].next;
  }

  function getPrev(Data storage self, uint _curr) public view returns (uint) {
    return self.dll[_curr].prev;
  }

  function getStart(Data storage self) public view returns (uint) {
    return getNext(self, NULL_NODE_ID);
  }

  function getEnd(Data storage self) public view returns (uint) {
    return getPrev(self, NULL_NODE_ID);
  }

  /**
  @dev Inserts a new node between _prev and _next. When inserting a node already existing in 
  the list it will be automatically removed from the old position.
  @param _prev the node which _new will be inserted after
  @param _curr the id of the new node being inserted
  @param _next the node which _new will be inserted before
  */
  function insert(Data storage self, uint _prev, uint _curr, uint _next) public {
    require(_curr != NULL_NODE_ID);

    remove(self, _curr);

    require(_prev == NULL_NODE_ID || contains(self, _prev));
    require(_next == NULL_NODE_ID || contains(self, _next));

    require(getNext(self, _prev) == _next);
    require(getPrev(self, _next) == _prev);

    self.dll[_curr].prev = _prev;
    self.dll[_curr].next = _next;

    self.dll[_prev].next = _curr;
    self.dll[_next].prev = _curr;
  }

  function remove(Data storage self, uint _curr) public {
    if (!contains(self, _curr)) {
      return;
    }

    uint next = getNext(self, _curr);
    uint prev = getPrev(self, _curr);

    self.dll[next].prev = prev;
    self.dll[prev].next = next;

    delete self.dll[_curr];
  }
}


/**
 * @dev Interface of the Whitelisting contract
 */
interface IContractWhitelist {
    /**
     * @dev Returns if contract isStakeWhitelisted
     */
    function isStakeWhitelisted(address _address) external view returns (bool);
    /**
     * @dev Returns if contract isRewardWhitelisted
     */
    function isRewardWhitelisted(address _address) external view returns (bool);
    /**
     * @dev Returns if contract isReputationWhitelisted
     */
    function isReputationWhitelisted(address _address) external view returns (bool);
}


interface IStakeManager {
    function ProxyStakeAllocate(uint256 _StakeAllocation, address _stakeholder) external returns(bool);
    function ProxyStakeDeallocate(uint256 _StakeToDeallocate, address _stakeholder) external returns(bool);
    //function TotalLockedStakes() external view returns(uint256);
    //function LockedStakedAmountOf(address _stakeholder) external view returns(uint256);
    //function AvailableStakedAmountOf(address _stakeholder) external view returns(uint256);
}


interface IRepManager {
    function ProxyAddReputation(uint256 rep, address _stakeholder) external returns(bool);
    function ProxyRemoveReputation(uint256 rep, address _stakeholder) external returns(bool);
}


interface IRewardManager {
    function ProxyAddReward(uint256 rw, address _stakeholder) external returns(bool);
    function ProxyRemoveRewards(uint256 rw, address _stakeholder) external returns(bool);
}

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
@title WorkSystem Spot v0.2
@author Mathias Dail
*/
contract WorkSystem is Ownable {

    // ============
    // EVENTS:
    // ============

    event _VoteCommitted(uint indexed DataID, uint numTokens, address indexed voter);
    event _VoteRevealed(uint indexed DataID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter);
    event _DataCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed DataID, address indexed creator);
    event _HashCertified(bytes32 hash, address indexed creator);
    event _VotingRightsGranted(uint numTokens, address indexed voter);
    event _VotingRightsWithdrawn(uint numTokens, address indexed voter);
    event _TokensRescued(uint indexed DataID, address indexed voter);

    // ============
    // DATA STRUCTURES:
    // ============

    using AttributeStore for AttributeStore.Data;
    using DLL for DLL.Data;
    using SafeMath for uint;
    
    enum HashStatus{
        TBD,
        VALID,
        DELETED
    }
    struct SpottedData {
        bytes32 ipfs_hash;                      // expiration date of commit period for Data
        address author;                         // author of the proposal
        HashStatus status;                      // state of the Spotted Data
        uint256 timestamp;                      // expiration date of commit period for Data
        string URL_domain;                      // URL domain
        string[] tags;                          // string tags
        uint256[] tags_id;                      // id of tags
        bytes32 extra;                          // extra_data
    }
    
    struct CertifiedHash {
        uint256 id;                             // id
        bytes32 hash;                           // expiration date of commit period for Data
        address author;                         // author of the proposal 
        uint256 certificationDate;              // expiration date of reveal period for Data
        uint256 totalVotes;		                // tally of token votes in this proposal
        uint256 DataID;                         // associated DataID
    }

    // ============
    // STATE VARIABLES:
    // ============

    uint constant INITIAL_Data_NONCE = 0;
    uint constant INITIAL_HASH_NONCE = 0;
    uint256 public DataNonce;
    uint public certifiedHashesNonce;
    
    uint public MIN_STAKE;
    uint public MIN_QUORUM;
    uint public MIN_PARTICIPANTS_FOR_VALIDITY;
    uint public COMMIT_ROUND_DURATION;
    uint public REVEAL_ROUND_DURATION;
    
    
    uint public MIN_REWARD_REVEAL = 10 * (10 ** 18);
    uint public MIN_REWARD_Data = 50 * (10 ** 18);
    uint public MIN_REP_REVEAL = 10 * (10 ** 18);
    uint public MIN_REP_Data  = 50 * (10 ** 18);
    
    mapping(address => DLL.Data) dllMap;
    AttributeStore.Data store;
    
    mapping(uint => Data) public DataMap; // maps DataID to Data struct
    mapping(address => uint256[]) public userDatasMap; // maps user's adresses to DataIDs they started
    mapping(address => uint) public SpotStakedTokenBalance; // maps user's address to voteToken balance
    
    CertifiedHash[] public CertifiedHashes;
    
    IERC20 public token;
    IContractWhitelist public whitelist;
    IStakeManager public StakeManager;
    IRepManager public RepManager;
    IRewardManager public RewardManager;

    /**
    @dev Initializer. Can only be called once.
    */
    constructor() public {
        address tracker_0x_address = 0x1d30b7d803B24498221538dFEc011043FE57De62;
        address whitelist_address = 0x7CD16b228f58a34E9860ee26533a5DF1A6E6E899;
        address reputation_mngr_address = 0xc9Cb2b63419254a5Af7aC1eE8EA3996f08f6c33A;
        address reward_mngr_address = 0xD3b4DbC1B4bbDcEb8c5d7e9CAD4acD19838F438f;
        address stake_mngr_address = 0x09FC387Bf4947bA145E429e802dC3FAC7292817C;
        
        token = IERC20(tracker_0x_address);
        whitelist = IContractWhitelist(whitelist_address);
        StakeManager = IStakeManager(stake_mngr_address);
        RepManager  = IRepManager(reputation_mngr_address);
        RewardManager  = IRewardManager(reward_mngr_address);
        
        DataNonce = INITIAL_Data_NONCE;
        certifiedHashesNonce = INITIAL_HASH_NONCE;
        
        MIN_STAKE = 100 * (10 ** 18);
        MIN_QUORUM = 50;
        MIN_PARTICIPANTS_FOR_VALIDITY = 1;
        COMMIT_ROUND_DURATION = 45;
        REVEAL_ROUND_DURATION = 45;
    }
    

    function updateStakeManager(address addr)
    public
    onlyOwner
    {
        StakeManager = IStakeManager(addr);
    }
    
    function updateRepManager(address addr)
    public
    onlyOwner
    {
        RepManager  = IRepManager(addr);
    }
    
    function updateRewardManager(address addr)
    public
    onlyOwner
    {
        RewardManager  = IRewardManager(addr);
    }
    
    function updateCommitRoundDuration(uint COMMIT_ROUND_DURATION_)
    public
    onlyOwner
    {
        COMMIT_ROUND_DURATION  = COMMIT_ROUND_DURATION_;
    }
    
    function updateRevealRoundDuration(uint REVEAL_ROUND_DURATION_)
    public
    onlyOwner
    {
        REVEAL_ROUND_DURATION  = REVEAL_ROUND_DURATION_;
    }



    // ================
    // TOKEN INTERFACE:
    // ================

    /**
    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights
    @dev Assumes that msg.sender has approved voting contract to spend on their behalf
    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens
    */
    function requestVotingRights(uint _numTokens) public {
        require(StakeManager.ProxyStakeAllocate(_numTokens, msg.sender));
        SpotStakedTokenBalance[msg.sender] += _numTokens;
        emit _VotingRightsGranted(_numTokens, msg.sender);
    }
    
    
    /**
    @notice Withdraw _numTokens ERC20 tokens from the voting contract, revoking these voting rights
    @param _numTokens The number of ERC20 tokens desired in exchange for voting rights
    */
    function withdrawVotingRights(uint _numTokens) external {
        uint availableTokens = SpotStakedTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));
        require(availableTokens >= _numTokens);
        require(StakeManager.ProxyStakeDeallocate(_numTokens, msg.sender));
        SpotStakedTokenBalance[msg.sender] -= _numTokens;
        emit _VotingRightsWithdrawn(_numTokens, msg.sender);
    }


    /**
    @dev Unlocks tokens locked in unrevealed vote where Data has ended
    @param _DataID Integer identifier associated with the target Data
    */
    function rescueTokens(uint _DataID) public {
        require(isExpired(DataMap[_DataID].revealEndDate));
        require(dllMap[msg.sender].contains(_DataID));

        dllMap[msg.sender].remove(_DataID);
        emit _TokensRescued(_DataID, msg.sender);
    }

    /**
    @dev Unlocks tokens locked in unrevealed votes where Datas have ended
    @param _DataIDs Array of integer identifiers associated with the target Datas
    */
    function rescueTokensInMultipleDatas(uint[] memory _DataIDs) public {
        // loop through arrays, rescuing tokens from all
        for (uint i = 0; i < _DataIDs.length; i++) {
            rescueTokens(_DataIDs[i]);
        }
    }

    // =================
    // VOTING INTERFACE:
    // =================

    /**
    @notice Commits vote using hash of choice and secret salt to conceal vote until reveal
    @param _DataID Integer identifier associated with target Data
    @param _secretHash Commit keccak256 hash of voter's choice and salt (tightly packed in this order)
    @param _prevDataID The ID of the Data that the user has voted the maximum number of tokens in which is still less than or equal to numTokens
    */
    function commitVote(uint _DataID, bytes32 _secretHash, uint _prevDataID) public {
        require(commitPeriodActive(_DataID));

        //_numTokens The number of tokens to be committed towards the target Data
        uint _numTokens = MIN_STAKE;
        
        // if msg.sender doesn't have enough voting rights,
        // request for enough voting rights
        if (SpotStakedTokenBalance[msg.sender] < _numTokens) {
            uint remainder = _numTokens.sub(SpotStakedTokenBalance[msg.sender]);
            requestVotingRights(remainder);
        }

        // make sure msg.sender has enough voting rights
        require(SpotStakedTokenBalance[msg.sender] >= _numTokens);
        // prevent user from committing to zero node placeholder
        require(_DataID != 0);
        // prevent user from committing a secretHash of 0
        require(_secretHash != 0);

        // Check if _prevDataID exists in the user's DLL or if _prevDataID is 0
        require(_prevDataID == 0 || dllMap[msg.sender].contains(_prevDataID));

        uint nextDataID = dllMap[msg.sender].getNext(_prevDataID);

        // edge case: in-place update
        if (nextDataID == _DataID) {
            nextDataID = dllMap[msg.sender].getNext(_DataID);
        }

        require(validPosition(_prevDataID, nextDataID, msg.sender, _numTokens));
        dllMap[msg.sender].insert(_prevDataID, _DataID, nextDataID);

        bytes32 UUID = attrUUID(msg.sender, _DataID);
        
        string memory nt = "numTokens";
        
        store.setAttribute(UUID,  nt, _numTokens);
        store.setAttribute(UUID, "commitHash", uint(_secretHash));

        DataMap[_DataID].didCommit[msg.sender] = true;
        emit _VoteCommitted(_DataID, _numTokens, msg.sender);
    }
    


    /**
    @notice                 Commits votes using hashes of choices and secret salts to conceal votes until reveal
    @param _DataIDs         Array of integer identifiers associated with target Datas
    @param _secretHashes    Array of commit keccak256 hashes of voter's choices and salts (tightly packed in this order)
    @param _prevDataIDs     Array of IDs of the Datas that the user has voted the maximum number of tokens in which is still less than or equal to numTokens
    */
    function commitVotes(uint[] calldata  _DataIDs, bytes32[] calldata _secretHashes, uint[] calldata _prevDataIDs) external {
        // make sure the array lengths are all the same
        require(_DataIDs.length == _secretHashes.length);
        require(_DataIDs.length == _prevDataIDs.length);
        
        // loop through arrays, committing each individual vote values
        for (uint i = 0; i < _DataIDs.length; i++) {
            commitVote(_DataIDs[i], _secretHashes[i], _prevDataIDs[i]);
        }
    }

    /**
    @dev Compares previous and next Data's committed tokens for sorting purposes
    @param _prevID Integer identifier associated with previous Data in sorted order
    @param _nextID Integer identifier associated with next Data in sorted order
    @param _voter Address of user to check DLL position for
    @param _numTokens The number of tokens to be committed towards the Data (used for sorting)
    @return valid Boolean indication of if the specified position maintains the sort
    */
    function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public view returns (bool valid) {
        bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));
        // if next is zero node, _numTokens does not need to be greater
        bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);
        return prevValid && nextValid;
    }

    /**
    @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
    @param _DataID Integer identifier associated with target Data
    @param _voteOption Vote choice used to generate commitHash for associated Data
    @param _salt Secret number used to generate commitHash for associated Data
    */
    function revealVote(uint _DataID, uint _voteOption, uint _salt) public {
        // Make sure the reveal period is active
        require(revealPeriodActive(_DataID));
        require(DataMap[_DataID].didCommit[msg.sender]);                         // make sure user has committed a vote for this Data
        require(!DataMap[_DataID].didReveal[msg.sender]);                        // prevent user from revealing multiple times
        require(keccak256(abi.encodePacked(_voteOption, _salt)) == getCommitHash(msg.sender, _DataID)); // compare resultant hash from inputs to original commitHash

        uint numTokens = getNumTokens(msg.sender, _DataID);

        if (_voteOption == 1) {// apply numTokens to appropriate Data choice
            DataMap[_DataID].votesFor += numTokens;
        } else {
            DataMap[_DataID].votesAgainst += numTokens;
        }

        dllMap[msg.sender].remove(_DataID); // remove the node referring to this vote upon reveal
        DataMap[_DataID].didReveal[msg.sender] = true;
        
        // ADD REWARDS AND REPUTATION
        require(RepManager.ProxyAddReputation(MIN_REP_REVEAL, msg.sender));
        require(RewardManager.ProxyAddReward(MIN_REWARD_REVEAL, msg.sender));

        emit _VoteRevealed(_DataID, numTokens, DataMap[_DataID].votesFor, DataMap[_DataID].votesAgainst, _voteOption, msg.sender);
    }

    /**
    @notice             Reveals multiple votes with choices and secret salts used in generating commitHashes to attribute committed tokens
    @param _DataIDs     Array of integer identifiers associated with target Datas
    @param _voteOptions Array of vote choices used to generate commitHashes for associated Datas
    @param _salts       Array of secret numbers used to generate commitHashes for associated Datas
    */
    function revealVotes(uint[] calldata _DataIDs, uint[] calldata _voteOptions, uint[] calldata _salts) external {
        // make sure the array lengths are all the same
        require(_DataIDs.length == _voteOptions.length);
        require(_DataIDs.length == _salts.length);

        // loop through arrays, revealing each individual vote values
        for (uint i = 0; i < _DataIDs.length; i++) {
            revealVote(_DataIDs[i], _voteOptions[i], _salts[i]);
        }
    }

    /**
    @param _DataID Integer identifier associated with target Data
    @param _salt Arbitrarily chosen integer used to generate secretHash
    @return correctVotes Number of tokens voted for winning option
    */
    function getNumPassingTokens(address _voter, uint _DataID, uint _salt) public view returns (uint correctVotes) {
        require(DataEnded(_DataID));
        require(DataMap[_DataID].didReveal[_voter]);

        uint winningChoice = isPassed(_DataID) ? 1 : 0;
        bytes32 winnerHash = keccak256(abi.encodePacked(winningChoice, _salt));
        bytes32 commitHash = getCommitHash(_voter, _DataID);

        require(winnerHash == commitHash);

        return getNumTokens(_voter, _DataID);
    }

    // ==================
    // DataING INTERFACE:
    // ==================

    /**
    @dev Initiates a Data with canonical configured parameters at DataID emitted by DataCreated event
    */
    function SpotSpottedData    
        (bytes32 file_hash, string URL_domain_, 
        string[] memory tags_, 
        string[] memory  tags_id_, bytes32 extra_) 
        
    public returns (uint256 Dataid_)
    
     {
        //_numTokens The number of tokens to be committed towards the target Data
        uint _numTokens = MIN_STAKE;
        
        // if msg.sender doesn't have enough voting rights,
        // request for enough voting rights
        if (SpotStakedTokenBalance[msg.sender] < _numTokens) {
            uint remainder = _numTokens.sub(SpotStakedTokenBalance[msg.sender]);
            requestVotingRights(remainder);
        }

        // make sure msg.sender has enough voting rights
        require(SpotStakedTokenBalance[msg.sender] >= _numTokens);
        // prevent user from committing a secretHash of 0
        require(file_hash != 0);
        
        
        
        DataNonce = DataNonce + 1;
        uint256 test = DataNonce;
        
        //_voteQuorum Type of majority (out of 100) that is necessary for Data to be successful
        uint _voteQuorum = MIN_QUORUM;
        // _commitDuration Length of desired commit period in seconds
        uint _commitDuration = COMMIT_ROUND_DURATION;
        // _revealDuration Length of desired commit period in seconds
        uint _revealDuration = REVEAL_ROUND_DURATION;

        uint commitEndDate = block.timestamp.add(_commitDuration);
        uint revealEndDate = commitEndDate.add(_revealDuration);
        
        userDatasMap[msg.sender].push(DataNonce);


        DataMap[DataNonce] = SpottedData({
            ipfs_hash: file_hash,
            author: msg.sender,
            status: HashStatus.TBD,
            timestamp: block.timestamp(),
            URL_domain: URL_domain_,
            tags: tags_,
            tags_id:  tags_id_,
            extra: extra_
        });

        emit _DataCreated(_voteQuorum, commitEndDate, revealEndDate, DataNonce, msg.sender);
        
        return DataNonce;
    }
    
    /**
    @dev Initiates a Data with canonical configured parameters at DataID emitted by DataCreated event
    */
    function dbg(bytes32 file_hash) public returns (uint256 Dataid_) {
        //_numTokens The number of tokens to be committed towards the target Data
        uint  _numTokens = MIN_STAKE;
        
        return  DataNonce;
    }
    
    /**
    @notice Trigger the validation of a Data hash; if the Data has ended. If the requirements are valid, 
    the CertifiedHash will be added to the valid list of CertifiedHashes
    @param _DataID Integer identifier associated with target Data
    */
    function ValidateSpottedData(uint _DataID) public {
        require(DataEnded(_DataID));
        require(isPassed(_DataID));
        // Build CertifiedHashes Struct
        uint token_vote_count = DataMap[_DataID].votesFor + DataMap[_DataID].votesAgainst;
        
        
        CertifiedHash memory ch =  CertifiedHash({
            id:                     certifiedHashesNonce++,
            hash:                   DataMap[_DataID].hash,
            author:                 DataMap[_DataID].author,
            certificationDate:      block.timestamp,
            totalVotes:             token_vote_count,
            DataID:                 _DataID
        });
        
        
        CertifiedHashes.push(ch);
        
        
        // ADD REWARDS AND REPUTATION
        require(RepManager.ProxyAddReputation(MIN_REP_Data, DataMap[_DataID].author));
        require(RewardManager.ProxyAddReward(MIN_REWARD_Data, DataMap[_DataID].author));
        
        emit _HashCertified(DataMap[_DataID].hash, DataMap[_DataID].author);
    }
    
    
    /**
    @notice Trigger the validation of a Data hash; if the Data has ended. If the requirements are valid, 
    the CertifiedHash will be added to the valid list of CertifiedHashes
    @param _DataID Integer identifier associated with target Data
    */
    function getTotalNumberOfVotes(uint _DataID) public view returns (uint vc)  {
        // Build CertifiedHashes Struct
        uint token_vote_count = DataMap[_DataID].votesFor + DataMap[_DataID].votesAgainst;
        return token_vote_count;
    }
    

    /**
    @notice Determines if proposal has passed
    @dev Check if votesFor out of totalVotes exceeds votesQuorum (requires DataEnded)
    @param _DataID Integer identifier associated with target Data
    */
    function isPassed(uint _DataID)  public view returns (bool passed) {
        require(DataEnded(_DataID));

        Data memory Data = DataMap[_DataID];
        return (100 * Data.votesFor) > (Data.voteQuorum * (Data.votesFor + Data.votesAgainst));
    }

    // ----------------
    // DataING HELPERS:
    // ----------------

    /**
    @dev Gets the total winning votes for reward distribution purposes
    @param _DataID Integer identifier associated with target Data
    @return numTokens of votes committed to the winning option for specified Data
    */
    function getTotalNumberOfTokensForWinningOption(uint _DataID) public view returns (uint numTokens) {
        require(DataEnded(_DataID));

        if (isPassed(_DataID))
            return DataMap[_DataID].votesFor;
        else
            return DataMap[_DataID].votesAgainst;
    }

    /**
    @notice Determines if Data is over
    @dev Checks isExpired for specified Data's revealEndDate
    @return ended Boolean indication of whether Dataing period is over
    */
    function DataEnded(uint _DataID) public view returns (bool ended) {
        require(DataExists(_DataID));

        return isExpired(DataMap[_DataID].revealEndDate);
    }
    
    /**
    @notice getUserDatas
    @return user_Datas the array of Datas started by the user
    */
    function getUserDatas(address user) public view returns (uint256[] memory user_Datas) {

        return userDatasMap[user];
    }
    
    /**
    @notice getLastUserDataId
    @return DataId of the last Dataed a user started
    */
    function getLastUserDataId(address user) public view returns (uint256 DataId) {
        uint256[] memory userDatas = userDatasMap[user];

        return  userDatas[ userDatas.length - 1 ];
    }
    
    /**
    @notice getLastDataId
    @return DataId of the last Dataed a user started
    */
    function getLastDataId() public view returns (uint256 DataId) {
        return  DataNonce;
    }
    
    /**
    @notice Determines DataCommitEndDate
    @return commitEndDate indication of whether Dataing period is over
    */
    function DataCommitEndDate(uint _DataID) public view returns (uint256 commitEndDate) {
        require(DataExists(_DataID));

        return DataMap[_DataID].commitEndDate;
    }
    
    
    /**
    @notice Determines DataRevealEndDate
    @return revealEndDate indication of whether Dataing period is over
    */
    function DataRevealEndDate(uint _DataID) public view returns (uint256 revealEndDate) {
        require(DataExists(_DataID));

        return DataMap[_DataID].revealEndDate;
    }
    
    /**
    @notice Checks if the commit period is still active for the specified Data
    @dev Checks isExpired for the specified Data's commitEndDate
    @param _DataID Integer identifier associated with target Data
    @return active Boolean indication of isCommitPeriodActive for target Data
    */
    function commitPeriodActive(uint _DataID) public view returns (bool active) {
        require(DataExists(_DataID));

        return !isExpired(DataMap[_DataID].commitEndDate);
    }

    /**
    @notice Checks if the reveal period is still active for the specified Data
    @dev Checks isExpired for the specified Data's revealEndDate
    @param _DataID Integer identifier associated with target Data
    */
    function revealPeriodActive(uint _DataID) public view returns (bool active) {
        require(DataExists(_DataID));

        return !isExpired(DataMap[_DataID].revealEndDate) && !commitPeriodActive(_DataID);
    }

    /**
    @dev Checks if user has committed for specified Data
    @param _voter Address of user to check against
    @param _DataID Integer identifier associated with target Data
    @return committed Boolean indication of whether user has committed
    */
    function didCommit(address _voter, uint _DataID) public view returns (bool committed) {
        require(DataExists(_DataID));

        return DataMap[_DataID].didCommit[_voter];
    }

    /**
    @dev Checks if user has revealed for specified Data
    @param _voter Address of user to check against
    @param _DataID Integer identifier associated with target Data
    @return revealed Boolean indication of whether user has revealed
    */
    function didReveal(address _voter, uint _DataID) public view returns (bool revealed) {
        require(DataExists(_DataID));

        return DataMap[_DataID].didReveal[_voter];
    }

    /**
    @dev Checks if a Data exists
    @param _DataID The DataID whose existance is to be evaluated.
    @return exists Boolean Indicates whether a Data exists for the provided DataID
    */
    function DataExists(uint _DataID) public view returns  (bool exists) {
        return (_DataID != 0 && _DataID <= DataNonce);
    }
    


    // ---------------------------
    // DOUBLE-LINKED-LIST HELPERS:
    // ---------------------------

    /**
    @dev Gets the bytes32 commitHash property of target Data
    @param _voter Address of user to check against
    @param _DataID Integer identifier associated with target Data
    @return commitHash Bytes32 hash property attached to target Data
    */
    function getCommitHash(address _voter, uint _DataID)  public view returns (bytes32 commitHash) {
        return bytes32(store.getAttribute(attrUUID(_voter, _DataID), "commitHash"));
    }

    /**
    @dev Wrapper for getAttribute with attrName="numTokens"
    @param _voter Address of user to check against
    @param _DataID Integer identifier associated with target Data
    @return numTokens Number of tokens committed to Data in sorted Data-linked-list
    */
    function getNumTokens(address _voter, uint _DataID)  public view returns (uint numTokens) {
        return store.getAttribute(attrUUID(_voter, _DataID), "numTokens");
    }

    /**
    @dev Gets top element of sorted Data-linked-list
    @param _voter Address of user to check against
    @return DataID Integer identifier to Data with maximum number of tokens committed to it
    */
    function getLastNode(address _voter)  public view returns (uint DataID) {
        return dllMap[_voter].getPrev(0);
    }

    /**
    @dev Gets the numTokens property of getLastNode
    @param _voter Address of user to check against
    @return numTokens Maximum number of tokens committed in Data specified
    */
    function getLockedTokens(address _voter)  public view returns (uint numTokens) {
        return getNumTokens(_voter, getLastNode(_voter));
    }

    /*
    @dev Takes the last node in the user's DLL and iterates backwards through the list searching
    for a node with a value less than or equal to the provided _numTokens value. When such a node
    is found, if the provided _DataID matches the found nodeID, this operation is an in-place
    update. In that case, return the previous node of the node being updated. Otherwise return the
    first node that was found with a value less than or equal to the provided _numTokens.
    @param _voter The voter whose DLL will be searched
    @param _numTokens The value for the numTokens attribute in the node to be inserted
    @return the node which the propoded node should be inserted after
    */
    function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _DataID) public view  returns (uint prevNode) {
      // Get the last node in the list and the number of tokens in that node
      uint nodeID = getLastNode(_voter);
      uint tokensInNode = getNumTokens(_voter, nodeID);

      // Iterate backwards through the list until reaching the root node
      while(nodeID != 0) {
        // Get the number of tokens in the current node
        tokensInNode = getNumTokens(_voter, nodeID);
        if(tokensInNode <= _numTokens) { // We found the insert point!
          if(nodeID == _DataID) {
            // This is an in-place update. Return the prev node of the node being updated
            nodeID = dllMap[_voter].getPrev(nodeID);
          }
          // Return the insert point
          return nodeID; 
        }
        // We did not find the insert point. Continue iterating backwards through the list
        nodeID = dllMap[_voter].getPrev(nodeID);
      }

      // The list is empty, or a smaller value than anything else in the list is being inserted
      return nodeID;
    }

    // ----------------
    // GENERAL HELPERS:
    // ----------------

    /**
    @dev Checks if an expiration date has been reached
    @param _terminationDate Integer timestamp of date to compare current timestamp with
    @return expired Boolean indication of whether the terminationDate has passed
    */
    function isExpired(uint _terminationDate)  public view returns (bool expired) {
        return (block.timestamp > _terminationDate);
    }
    
    /**
    @return keccak256hash  Hash which is deterministic from a and b
    */
    function getHash(uint a, uint b) public pure returns (bytes32 keccak256hash) {
        return keccak256(abi.encodePacked(a, b));
    }
    
    /**
    @return blocktimestamp block.timestamp
    */
    function getBlockTimestamp()  public view returns (uint blocktimestamp) {
        return block.timestamp;
    }


    /**
    @dev Generates an identifier which associates a user and a Data together
    @param _DataID Integer identifier associated with target Data
    @return UUID Hash which is deterministic from _user and _DataID
    */
    function attrUUID(address _user, uint _DataID) public pure returns (bytes32 UUID) {
        return keccak256(abi.encodePacked(_user, _DataID));
    }
}
